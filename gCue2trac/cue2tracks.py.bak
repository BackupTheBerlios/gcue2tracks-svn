#!/usr/bin/python
#

import gtk
import gtk.glade
#import sys   
import threading
import Queue
#import time
import popen2
#import re
import string
class aJob:

	def __init__(self,id,label):
		"""
		instance variables:
		id: a unique job id
		label: a label (url to fect, file to read, whatever)
		result: this will store the result (content of the file, whatever)
		"""
		self.id=id
		self.label=label
		self.result=None
		
class GuiPart:
	def __init__(self,qIn,qOut):
		"""
		qIn in a Queue.Queue that store jobs to be done
		qOut is a Queue.Queue that store result of completed jobs
		The GuiPart is supposed to push stuff in qIn ,and regularly check
		if new result are available in qOut
		"""
		self.qIn=qIn
		self.qOut=qOut
		self.jobCounter=0
		self.currentJobId=None
		gladefile = "pywine.glade"  
		GuiPart.wTree = gtk.glade.XML(gladefile, "mainWindow") 
		#combobox = GuiPart.wTree.get_widget("combobox1")
		#iter=combobox.set_active(0)	
		#Create our dictionay and connect it
		dic = {"on_mainWindow_destroy" : self.endApplication
				, "onf" : self.onf, "start_recomp" : self.start_recomp}
		GuiPart.wTree.signal_autoconnect(dic)

	def onf(self, widget):
		dialog = gtk.FileChooserDialog("Open..",
                       None,
                       gtk.FILE_CHOOSER_ACTION_OPEN,
                       (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                        gtk.STOCK_OPEN, gtk.RESPONSE_OK))
		dialog.set_default_response(gtk.RESPONSE_OK)

		filter = gtk.FileFilter()
		filter.set_name("Cue")
#		filter.add_mime_type("image/png")
#		filter.add_mime_type("image/jpeg")
#		filter.add_mime_type("image/gif")
		filter.add_pattern("*.cue")
#		filter.add_pattern("*.jpg")
#		filter.add_pattern("*.gif")
#		filter.add_pattern("*.tif")
#		filter.add_pattern("*.xpm")
		dialog.add_filter(filter)
		filter = gtk.FileFilter()
		filter.set_name("All files")
		filter.add_pattern("*")
		dialog.add_filter(filter)
		response = dialog.run()
		if response == gtk.RESPONSE_OK:
			self.entry = GuiPart.wTree.get_widget("entry1")
			self.entry.set_text(dialog.get_filename())
			GuiPart.fileselect= dialog.get_filename()
			#self.save = GuiPart.wTree.get_widget("save")
			#self.save.set_title(dialog.get_filename())
			self.start = GuiPart.wTree.get_widget("start")
			self.start.set_sensitive(True)
		elif response == gtk.RESPONSE_CANCEL:
		   print "Closed, no files selected"	
		dialog.destroy()
		
	def start_recomp(self, widget):	
		combobox = GuiPart.wTree.get_widget("combobox1")
		codec=combobox.get_active_text()
		#print codec
		#iter=combobox.set_active(0)
		#print iter
		GuiPart.a=unicode('cue2tracks -c ' + codec + ' -Q7 -f cp1251 -R ' + '"' + GuiPart.fileselect + '"')
		print GuiPart.a
		GuiPart.textview = GuiPart.wTree.get_widget("textview1")
		GuiPart.textbuffer=GuiPart.textview.get_buffer()
		#GuiPart.textbuffer.set_text('111111111')
		#GuiPart.textbuffer.set_text("22222222")
		self.goButton_clicked(widget)
		#time.sleep(3)		

	def processOutcoming(self):
		"""Handle all jobs currently in qOut, if any"""

		#        print "processOutcoming called"
		if self.currentJobId!=None:
			path=str(self.currentJobId)
			treeiter=self.treestore1.get_iter(path)
			self.treestore1.set_value(treeiter,2,'processing')


		#if self.qIn.qsize() or self.currentJobId!=None:
			#self.progressbar1=self.xml.get_widget('progressbar1')
			#self.progressbar1.show()
			#self.progressbar1.pulse()
		#else:
			#self.progressbar1.hide()

		while self.qOut.qsize():
			try:
				job=self.qOut.get(0)
		#                print "We have to deal with job",job.label
				self.processResult(job)
			except Queue.Empty:
				print "qOut is empty"
				pass

		return gtk.TRUE
   
	def processResult(self,job):
		"""a new job has been processed, we have to display the result"""
		id=job.id
		path=str(id)
		treeiter=self.treestore1.get_iter(path)
		self.treestore1.set_value(treeiter,2,'done')


	def goButton_clicked(self,widget):
		#label=self.xml.get_widget('entry1').get_text()
		#self.xml.get_widget('entry1').set_text('')
		id=self.jobCounter
		self.jobCounter+=1
		job=aJob(id,'11')
		#self.treestore1.append(None,[id,label,'pending'])
		self.qIn.put(job)



	def quitButton_clicked(self,widget):
		self.endApplication()

	def endApplication(self,widget):
		print "time to die"
		gtk.main_quit()

class ThreadedClient:
    """
    This class launch the GuiPart and the worker thread.
    """

    def __init__(self):
        """
        This start the gui in a asynchronous thread.
        We are in the "main" thread of the application,
         wich will later be used by the gui as well.
          We spawn a new thread for the worker
        """
        gtk.gdk.threads_init()
        self.qIn=Queue.Queue()
        self.qOut=Queue.Queue()
        self.gui=GuiPart(self.qIn,self.qOut)
        self.running=True
        self.incomingThread=threading.Thread(target=self.processIncoming)
        print "plop=",self.incomingThread
        self.incomingThread.setDaemon(True)
        self.incomingThread.start()
        #print "pika=",pika
        #gtk.threads_enter()
        gtk.main()
        self.running=False
        #gtk.threads_leave()

    def processIncoming(self):
       """
       This is where the blocking I/O job is being done.
       """
       while self.running:
           while self.qIn.qsize():
#               print "There are stuff in qIn"
               try:
                   job=self.qIn.get(0)
                   self.gui.currentJobId=job.id
                   proc1 = popen2.Popen4(GuiPart.a)
                   gtk.gdk.threads_enter()
                   fromchild = proc1.fromchild.readline()
                   #GuiPart.textbuffer.set_text(fromchild + '\n')
                   gtk.gdk.threads_leave()
                   #print fromchild
                   while fromchild:
                   	   fromchild = proc1.fromchild.readline()
                   	   a=string.find(fromchild,'%')
                   	   #print a
                   	   if a<>-1:
                   	   	fromchild = fromchild[:(a-3)]
                   	   #regxp2 = re.compile('\033..')
                   	   #regxp1 = re.compile('\033....')
                   	   #regxp = re.compile('\033.......')
                   	   #fromchild = regxp.sub(' ',fromchild)
                   	   #fromchild = regxp1.sub(' ',fromchild)
                   	   #fromchild = regxp2.sub(' ',fromchild)
                   	   print fromchild
                   	   gtk.gdk.threads_enter()
                   	   #GuiPart.wTree.get_widget("progressbar1").pulse()
                   	   buff=GuiPart.textbuffer.get_text(GuiPart.textbuffer.get_start_iter(),\
                   	   GuiPart.textbuffer.get_end_iter())                  	   
                   	   GuiPart.textbuffer.set_text( buff+fromchild+ '\n')
                   	   match_start_mark = GuiPart.textbuffer.create_mark('match_start',\
                   	   GuiPart.textbuffer.get_end_iter(), True)
                   	   GuiPart.textview.scroll_to_mark(match_start_mark, 0, True)
                   	   gtk.gdk.threads_leave()	
                   job.result='we would store the resutl here'
                   self.gui.currentJobId=None
                   self.qOut.put(job)
               except Queue.Empty:
                   pass
           #time.sleep(2)   

    def endApplication(self):
        self.running=False

plop=ThreadedClient()
